"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var tls = _interopRequireWildcard(require("tls"));

var _events = require("events");

var _message = _interopRequireDefault(require("./message"));

var _packet = require("./packet");

var _incomingMessageStream = _interopRequireDefault(require("./incoming-message-stream"));

var _outgoingMessageStream = _interopRequireDefault(require("./outgoing-message-stream"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// eslint-disable-next-line @typescript-eslint/no-var-requires
const DuplexPair = require('native-duplexpair');

class MessageIO extends _events.EventEmitter {
  constructor(socket, packetSize, debug) {
    super();
    this.socket = void 0;
    this.debug = void 0;
    this.tlsNegotiationComplete = void 0;
    this.incomingMessageStream = void 0;
    this.outgoingMessageStream = void 0;
    this.securePair = void 0;
    this.socket = socket;
    this.debug = debug;
    this.tlsNegotiationComplete = false;
    this.incomingMessageStream = new _incomingMessageStream.default(this.debug);
    this.incomingMessageStream.on('data', message => {
      this.emit('data', message);
    });
    this.incomingMessageStream.on('error', message => {
      this.emit('error', message);
    });
    this.outgoingMessageStream = new _outgoingMessageStream.default(this.debug, {
      packetSize: packetSize
    });
    this.socket.pipe(this.incomingMessageStream);
    this.outgoingMessageStream.pipe(this.socket);
  }

  packetSize(...args) {
    if (args.length > 0) {
      const packetSize = args[0];
      this.debug.log('Packet size changed from ' + this.outgoingMessageStream.packetSize + ' to ' + packetSize);
      this.outgoingMessageStream.packetSize = packetSize;
    }

    if (this.securePair) {
      this.securePair.cleartext.setMaxSendFragment(this.outgoingMessageStream.packetSize);
    }

    return this.outgoingMessageStream.packetSize;
  }

  startTls(secureContext, hostname, trustServerCertificate) {
    const duplexpair = new DuplexPair();
    const securePair = this.securePair = {
      cleartext: tls.connect({
        socket: duplexpair.socket1,
        servername: hostname,
        secureContext: secureContext,
        rejectUnauthorized: !trustServerCertificate
      }),
      encrypted: duplexpair.socket2
    }; // If an error happens in the TLS layer, there is nothing we can do about it.
    // Forward the error to the socket so the connection gets properly cleaned up.

    securePair.cleartext.on('error', err => {
      // Streams in node.js versions before 8.0.0 don't support `.destroy`
      if (typeof securePair.encrypted.destroy === 'function') {
        securePair.encrypted.destroy();
      }

      this.socket.destroy(err);
    });
    securePair.cleartext.on('secureConnect', () => {
      const cipher = securePair.cleartext.getCipher();

      if (cipher) {
        this.debug.log('TLS negotiated (' + cipher.name + ', ' + cipher.version + ')');
      }

      this.emit('secure', securePair.cleartext);
      this.encryptAllFutureTraffic();
    });
    securePair.encrypted.on('data', data => {
      this.sendMessage(_packet.TYPE.PRELOGIN, data, false);
    });
  }

  encryptAllFutureTraffic() {
    const securePair = this.securePair;
    securePair.cleartext.setMaxSendFragment(this.outgoingMessageStream.packetSize);
    securePair.encrypted.removeAllListeners('data');
    this.outgoingMessageStream.unpipe(this.socket);
    this.socket.unpipe(this.incomingMessageStream);
    this.socket.pipe(securePair.encrypted);
    securePair.encrypted.pipe(this.socket);
    securePair.cleartext.pipe(this.incomingMessageStream);
    this.outgoingMessageStream.pipe(securePair.cleartext);
    this.tlsNegotiationComplete = true;
  }

  tlsHandshakeData(data) {
    const securePair = this.securePair;
    securePair.encrypted.write(data);
  } // TODO listen for 'drain' event when socket.write returns false.
  // TODO implement incomplete request cancelation (2.2.1.6)


  sendMessage(packetType, data, resetConnection) {
    const message = new _message.default({
      type: packetType,
      resetConnection: resetConnection
    });
    message.end(data);
    this.outgoingMessageStream.write(message);
    return message;
  } // Temporarily suspends the flow of incoming packets.


  pause() {
    this.incomingMessageStream.pause();
  } // Resumes the flow of incoming packets.


  resume() {
    this.incomingMessageStream.resume();
  }

}

var _default = MessageIO;
exports.default = _default;
module.exports = MessageIO;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9tZXNzYWdlLWlvLnRzIl0sIm5hbWVzIjpbIkR1cGxleFBhaXIiLCJyZXF1aXJlIiwiTWVzc2FnZUlPIiwiRXZlbnRFbWl0dGVyIiwiY29uc3RydWN0b3IiLCJzb2NrZXQiLCJwYWNrZXRTaXplIiwiZGVidWciLCJ0bHNOZWdvdGlhdGlvbkNvbXBsZXRlIiwiaW5jb21pbmdNZXNzYWdlU3RyZWFtIiwib3V0Z29pbmdNZXNzYWdlU3RyZWFtIiwic2VjdXJlUGFpciIsIkluY29taW5nTWVzc2FnZVN0cmVhbSIsIm9uIiwibWVzc2FnZSIsImVtaXQiLCJPdXRnb2luZ01lc3NhZ2VTdHJlYW0iLCJwaXBlIiwiYXJncyIsImxlbmd0aCIsImxvZyIsImNsZWFydGV4dCIsInNldE1heFNlbmRGcmFnbWVudCIsInN0YXJ0VGxzIiwic2VjdXJlQ29udGV4dCIsImhvc3RuYW1lIiwidHJ1c3RTZXJ2ZXJDZXJ0aWZpY2F0ZSIsImR1cGxleHBhaXIiLCJ0bHMiLCJjb25uZWN0Iiwic29ja2V0MSIsInNlcnZlcm5hbWUiLCJyZWplY3RVbmF1dGhvcml6ZWQiLCJlbmNyeXB0ZWQiLCJzb2NrZXQyIiwiZXJyIiwiZGVzdHJveSIsImNpcGhlciIsImdldENpcGhlciIsIm5hbWUiLCJ2ZXJzaW9uIiwiZW5jcnlwdEFsbEZ1dHVyZVRyYWZmaWMiLCJkYXRhIiwic2VuZE1lc3NhZ2UiLCJUWVBFIiwiUFJFTE9HSU4iLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJ1bnBpcGUiLCJ0bHNIYW5kc2hha2VEYXRhIiwid3JpdGUiLCJwYWNrZXRUeXBlIiwicmVzZXRDb25uZWN0aW9uIiwiTWVzc2FnZSIsInR5cGUiLCJlbmQiLCJwYXVzZSIsInJlc3VtZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFJQTs7QUFFQTs7QUFJQTs7QUFDQTs7QUFFQTs7QUFDQTs7Ozs7Ozs7QUFkQTtBQUNBLE1BQU1BLFVBQVUsR0FBR0MsT0FBTyxDQUFDLG1CQUFELENB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cUJoQixJQUFyQixDQUEwQixLQUFLWixNQUEvQjtBQUVBTSxJQUFBQSxVQUFVLENBQUNVLFNBQVgsQ0FBcUJKLElBQXJCLENBQTBCLEtBQUtSLHFCQUEvQjtBQUNBLFNBQUtDLHFCQUFMLENBQTJCTyxJQUEzQixDQUFnQ04sVUFBVSxDQUFDVSxTQUEzQztBQUVBLFNBQUtiLHNCQUFMLEdBQThCLElBQTlCO0FBQ0Q7O0FBRUR3QyxFQUFBQSxnQkFBZ0IsQ0FBQ04sSUFBRCxFQUFlO0FBQzdCLFVBQU0vQixVQUFVLEdBQUcsS0FBS0EsVUFBeEI7QUFFQUEsSUFBQUEsVUFBVSxDQUFDc0IsU0FBWCxDQUFxQmdCLEtBQXJCLENBQTJCUCxJQUEzQjtBQUNELEdBN0drQyxDQStHbkM7QUFDQTs7O0FBQ0FDLEVBQUFBLFdBQVcsQ0FBQ08sVUFBRCxFQUFxQlIsSUFBckIsRUFBb0NTLGVBQXBDLEVBQStEO0FBQ3hFLFVBQU1yQyxPQUFPLEdBQUcsSUFBSXNDLGdCQUFKLENBQVk7QUFBRUMsTUFBQUEsSUFBSSxFQUFFSCxVQUFSO0FBQW9CQyxNQUFBQSxlQUFlLEVBQUVBO0FBQXJDLEtBQVosQ0FBaEI7QUFDQXJDLElBQUFBLE9BQU8sQ0FBQ3dDLEdBQVIsQ0FBWVosSUFBWjtBQUNBLFNBQUtoQyxxQkFBTCxDQUEyQnVDLEtBQTNCLENBQWlDbkMsT0FBakM7QUFDQSxXQUFPQSxPQUFQO0FBQ0QsR0F0SGtDLENBd0huQzs7O0FBQ0F5QyxFQUFBQSxLQUFLLEdBQUc7QUFDTixTQUFLOUMscUJBQUwsQ0FBMkI4QyxLQUEzQjtBQUNELEdBM0hrQyxDQTZIbkM7OztBQUNBQyxFQUFBQSxNQUFNLEdBQUc7QUFDUCxTQUFLL0MscUJBQUwsQ0FBMkIrQyxNQUEzQjtBQUNEOztBQWhJa0M7O2VBbUl0QnRELFM7O0FBQ2Z1RCxNQUFNLENBQUNDLE9BQVAsR0FBaUJ4RCxTQUFqQiIsInNvdXJjZXNDb250ZW50IjpbIi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdmFyLXJlcXVpcmVzXG5jb25zdCBEdXBsZXhQYWlyID0gcmVxdWlyZSgnbmF0aXZlLWR1cGxleHBhaXInKTtcblxuaW1wb3J0IHsgRHVwbGV4IH0gZnJvbSAnc3RyZWFtJztcbmltcG9ydCAqIGFzIHRscyBmcm9tICd0bHMnO1xuaW1wb3J0IHsgU29ja2V0IH0gZnJvbSAnbmV0JztcbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ2V2ZW50cyc7XG5cbmltcG9ydCBEZWJ1ZyBmcm9tICcuL2RlYnVnJztcblxuaW1wb3J0IE1lc3NhZ2UgZnJvbSAnLi9tZXNzYWdlJztcbmltcG9ydCB7IFRZUEUgfSBmcm9tICcuL3BhY2tldCc7XG5cbmltcG9ydCBJbmNvbWluZ01lc3NhZ2VTdHJlYW0gZnJvbSAnLi9pbmNvbWluZy1tZXNzYWdlLXN0cmVhbSc7XG5pbXBvcnQgT3V0Z29pbmdNZXNzYWdlU3RyZWFtIGZyb20gJy4vb3V0Z29pbmctbWVzc2FnZS1zdHJlYW0nO1xuXG5jbGFzcyBNZXNzYWdlSU8gZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBzb2NrZXQ6IFNvY2tldDtcbiAgZGVidWc6IERlYnVnO1xuXG4gIHRsc05lZ290aWF0aW9uQ29tcGxldGU6IGJvb2xlYW47XG5cbiAgaW5jb21pbmdNZXNzYWdlU3RyZWFtOiBJbmNvbWluZ01lc3NhZ2VTdHJlYW07XG4gIG91dGdvaW5nTWVzc2FnZVN0cmVhbTogT3V0Z29pbmdNZXNzYWdlU3RyZWFtO1xuXG4gIHNlY3VyZVBhaXI/OiB7XG4gICAgY2xlYXJ0ZXh0OiB0bHMuVExTU29ja2V0O1xuICAgIGVuY3J5cHRlZDogRHVwbGV4O1xuICB9XG5cbiAgY29uc3RydWN0b3Ioc29ja2V0OiBTb2NrZXQsIHBhY2tldFNpemU6IG51bWJlciwgZGVidWc6IERlYnVnKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuc29ja2V0ID0gc29ja2V0O1xuICAgIHRoaXMuZGVidWcgPSBkZWJ1ZztcblxuICAgIHRoaXMudGxzTmVnb3RpYXRpb25Db21wbGV0ZSA9IGZhbHNlO1xuXG4gICAgdGhpcy5pbmNvbWluZ01lc3NhZ2VTdHJlYW0gPSBuZXcgSW5jb21pbmdNZXNzYWdlU3RyZWFtKHRoaXMuZGVidWcpO1xuICAgIHRoaXMuaW5jb21pbmdNZXNzYWdlU3RyZWFtLm9uKCdkYXRhJywgKG1lc3NhZ2U6IE1lc3NhZ2UpID0+IHtcbiAgICAgIHRoaXMuZW1pdCgnZGF0YScsIG1lc3NhZ2UpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5pbmNvbWluZ01lc3NhZ2VTdHJlYW0ub24oJ2Vycm9yJywgKG1lc3NhZ2UpID0+IHtcbiAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBtZXNzYWdlKTtcbiAgICB9KTtcblxuICAgIHRoaXMub3V0Z29pbmdNZXNzYWdlU3RyZWFtID0gbmV3IE91dGdvaW5nTWVzc2FnZVN0cmVhbSh0aGlzLmRlYnVnLCB7IHBhY2tldFNpemU6IHBhY2tldFNpemUgfSk7XG5cbiAgICB0aGlzLnNvY2tldC5waXBlKHRoaXMuaW5jb21pbmdNZXNzYWdlU3RyZWFtKTtcbiAgICB0aGlzLm91dGdvaW5nTWVzc2FnZVN0cmVhbS5waXBlKHRoaXMuc29ja2V0KTtcbiAgfVxuXG4gIHBhY2tldFNpemUoLi4uYXJnczogW251bWJlcl0pIHtcbiAgICBpZiAoYXJncy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBwYWNrZXRTaXplID0gYXJnc1swXTtcbiAgICAgIHRoaXMuZGVidWcubG9nKCdQYWNrZXQgc2l6ZSBjaGFuZ2VkIGZyb20gJyArIHRoaXMub3V0Z29pbmdNZXNzYWdlU3RyZWFtLnBhY2tldFNpemUgKyAnIHRvICcgKyBwYWNrZXRTaXplKTtcbiAgICAgIHRoaXMub3V0Z29pbmdNZXNzYWdlU3RyZWFtLnBhY2tldFNpemUgPSBwYWNrZXRTaXplO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnNlY3VyZVBhaXIpIHtcbiAgICAgIHRoaXMuc2VjdXJlUGFpci5jbGVhcnRleHQuc2V0TWF4U2VuZEZyYWdtZW50KHRoaXMub3V0Z29pbmdNZXNzYWdlU3RyZWFtLnBhY2tldFNpemUpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLm91dGdvaW5nTWVzc2FnZVN0cmVhbS5wYWNrZXRTaXplO1xuICB9XG5cbiAgc3RhcnRUbHMoc2VjdXJlQ29udGV4dDogdGxzLlNlY3VyZUNvbnRleHQsIGhvc3RuYW1lOiBzdHJpbmcsIHRydXN0U2VydmVyQ2VydGlmaWNhdGU6IGJvb2xlYW4pIHtcbiAgICBjb25zdCBkdXBsZXhwYWlyID0gbmV3IER1cGxleFBhaXIoKTtcbiAgICBjb25zdCBzZWN1cmVQYWlyID0gdGhpcy5zZWN1cmVQYWlyID0ge1xuICAgICAgY2xlYXJ0ZXh0OiB0bHMuY29ubmVjdCh7XG4gICAgICAgIHNvY2tldDogZHVwbGV4cGFpci5zb2NrZXQxIGFzIFNvY2tldCxcbiAgICAgICAgc2VydmVybmFtZTogaG9zdG5hbWUsXG4gICAgICAgIHNlY3VyZUNvbnRleHQ6IHNlY3VyZUNvbnRleHQsXG4gICAgICAgIHJlamVjdFVuYXV0aG9yaXplZDogIXRydXN0U2VydmVyQ2VydGlmaWNhdGVcbiAgICAgIH0pLFxuICAgICAgZW5jcnlwdGVkOiBkdXBsZXhwYWlyLnNvY2tldDJcbiAgICB9O1xuXG4gICAgLy8gSWYgYW4gZXJyb3IgaGFwcGVucyBpbiB0aGUgVExTIGxheWVyLCB0aGVyZSBpcyBub3RoaW5nIHdlIGNhbiBkbyBhYm91dCBpdC5cbiAgICAvLyBGb3J3YXJkIHRoZSBlcnJvciB0byB0aGUgc29ja2V0IHNvIHRoZSBjb25uZWN0aW9uIGdldHMgcHJvcGVybHkgY2xlYW5lZCB1cC5cbiAgICBzZWN1cmVQYWlyLmNsZWFydGV4dC5vbignZXJyb3InLCAoZXJyPzogRXJyb3IpID0+IHtcbiAgICAgIC8vIFN0cmVhbXMgaW4gbm9kZS5qcyB2ZXJzaW9ucyBiZWZvcmUgOC4wLjAgZG9uJ3Qgc3VwcG9ydCBgLmRlc3Ryb3lgXG4gICAgICBpZiAodHlwZW9mIHNlY3VyZVBhaXIuZW5jcnlwdGVkLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgc2VjdXJlUGFpci5lbmNyeXB0ZWQuZGVzdHJveSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5zb2NrZXQuZGVzdHJveShlcnIpO1xuICAgIH0pO1xuXG4gICAgc2VjdXJlUGFpci5jbGVhcnRleHQub24oJ3NlY3VyZUNvbm5lY3QnLCAoKSA9PiB7XG4gICAgICBjb25zdCBjaXBoZXIgPSBzZWN1cmVQYWlyLmNsZWFydGV4dC5nZXRDaXBoZXIoKTtcbiAgICAgIGlmIChjaXBoZXIpIHtcbiAgICAgICAgdGhpcy5kZWJ1Zy5sb2coJ1RMUyBuZWdvdGlhdGVkICgnICsgY2lwaGVyLm5hbWUgKyAnLCAnICsgY2lwaGVyLnZlcnNpb24gKyAnKScpO1xuICAgICAgfVxuICAgICAgdGhpcy5lbWl0KCdzZWN1cmUnLCBzZWN1cmVQYWlyLmNsZWFydGV4dCk7XG4gICAgICB0aGlzLmVuY3J5cHRBbGxGdXR1cmVUcmFmZmljKCk7XG4gICAgfSk7XG5cbiAgICBzZWN1cmVQYWlyLmVuY3J5cHRlZC5vbignZGF0YScsIChkYXRhOiBCdWZmZXIpID0+IHtcbiAgICAgIHRoaXMuc2VuZE1lc3NhZ2UoVFlQRS5QUkVMT0dJTiwgZGF0YSwgZmFsc2UpO1xuICAgIH0pO1xuICB9XG5cbiAgZW5jcnlwdEFsbEZ1dHVyZVRyYWZmaWMoKSB7XG4gICAgY29uc3Qgc2VjdXJlUGFpciA9IHRoaXMuc2VjdXJlUGFpciE7XG5cbiAgICBzZWN1cmVQYWlyLmNsZWFydGV4dC5zZXRNYXhTZW5kRnJhZ21lbnQodGhpcy5vdXRnb2luZ01lc3NhZ2VTdHJlYW0ucGFja2V0U2l6ZSk7XG4gICAgc2VjdXJlUGFpci5lbmNyeXB0ZWQucmVtb3ZlQWxsTGlzdGVuZXJzKCdkYXRhJyk7XG5cbiAgICB0aGlzLm91dGdvaW5nTWVzc2FnZVN0cmVhbS51bnBpcGUodGhpcy5zb2NrZXQpO1xuICAgIHRoaXMuc29ja2V0LnVucGlwZSh0aGlzLmluY29taW5nTWVzc2FnZVN0cmVhbSk7XG5cbiAgICB0aGlzLnNvY2tldC5waXBlKHNlY3VyZVBhaXIuZW5jcnlwdGVkKTtcbiAgICBzZWN1cmVQYWlyLmVuY3J5cHRlZC5waXBlKHRoaXMuc29ja2V0KTtcblxuICAgIHNlY3VyZVBhaXIuY2xlYXJ0ZXh0LnBpcGUodGhpcy5pbmNvbWluZ01lc3NhZ2VTdHJlYW0pO1xuICAgIHRoaXMub3V0Z29pbmdNZXNzYWdlU3RyZWFtLnBpcGUoc2VjdXJlUGFpci5jbGVhcnRleHQpO1xuXG4gICAgdGhpcy50bHNOZWdvdGlhdGlvbkNvbXBsZXRlID0gdHJ1ZTtcbiAgfVxuXG4gIHRsc0hhbmRzaGFrZURhdGEoZGF0YTogQnVmZmVyKSB7XG4gICAgY29uc3Qgc2VjdXJlUGFpciA9IHRoaXMuc2VjdXJlUGFpciE7XG5cbiAgICBzZWN1cmVQYWlyLmVuY3J5cHRlZC53cml0ZShkYXRhKTtcbiAgfVxuXG4gIC8vIFRPRE8gbGlzdGVuIGZvciAnZHJhaW4nIGV2ZW50IHdoZW4gc29ja2V0LndyaXRlIHJldHVybnMgZmFsc2UuXG4gIC8vIFRPRE8gaW1wbGVtZW50IGluY29tcGxldGUgcmVxdWVzdCBjYW5jZWxhdGlvbiAoMi4yLjEuNilcbiAgc2VuZE1lc3NhZ2UocGFja2V0VHlwZTogbnVtYmVyLCBkYXRhPzogQnVmZmVyLCByZXNldENvbm5lY3Rpb24/OiBib29sZWFuKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IG5ldyBNZXNzYWdlKHsgdHlwZTogcGFja2V0VHlwZSwgcmVzZXRDb25uZWN0aW9uOiByZXNldENvbm5lY3Rpb24gfSk7XG4gICAgbWVzc2FnZS5lbmQoZGF0YSk7XG4gICAgdGhpcy5vdXRnb2luZ01lc3NhZ2VTdHJlYW0ud3JpdGUobWVzc2FnZSk7XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH1cblxuICAvLyBUZW1wb3JhcmlseSBzdXNwZW5kcyB0aGUgZmxvdyBvZiBpbmNvbWluZyBwYWNrZXRzLlxuICBwYXVzZSgpIHtcbiAgICB0aGlzLmluY29taW5nTWVzc2FnZVN0cmVhbS5wYXVzZSgpO1xuICB9XG5cbiAgLy8gUmVzdW1lcyB0aGUgZmxvdyBvZiBpbmNvbWluZyBwYWNrZXRzLlxuICByZXN1bWUoKSB7XG4gICAgdGhpcy5pbmNvbWluZ01lc3NhZ2VTdHJlYW0ucmVzdW1lKCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTWVzc2FnZUlPO1xubW9kdWxlLmV4cG9ydHMgPSBNZXNzYWdlSU87XG4iXX0=