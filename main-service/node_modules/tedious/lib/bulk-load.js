"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _events = require("events");

var _writableTrackingBuffer = _interopRequireDefault(require("./tracking-buffer/writable-tracking-buffer"));

var _stream = require("stream");

var _token = require("./token/token");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @private
 */
const FLAGS = {
  nullable: 1 << 0,
  caseSen: 1 << 1,
  updateableReadWrite: 1 << 2,
  updateableUnknown: 1 << 3,
  identity: 1 << 4,
  computed: 1 << 5,
  // introduced in TDS 7.2
  fixedLenCLRType: 1 << 8,
  // introduced in TDS 7.2
  sparseColumnSet: 1 << 10,
  // introduced in TDS 7.3.B
  hidden: 1 << 13,
  // introduced in TDS 7.2
  key: 1 << 14,
  // introduced in TDS 7.2
  nullableUnknown: 1 << 15 // introduced in TDS 7.2

};
/**
 * @private
 */

const DONE_STATUS = {
  FINAL: 0x00,
  MORE: 0x1,
  ERROR: 0x2,
  INXACT: 0x4,
  COUNT: 0x10,
  ATTN: 0x20,
  SRVERROR: 0x100
};
/**
 * @private
 */

const rowTokenBuffer = Buffer.from([_token.TYPE.ROW]);
const textPointerAndTimestampBuffer = Buffer.from([// TextPointer length
0x10, // TextPointer
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Timestamp
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);
const textPointerNullBuffer = Buffer.from([0x00]); // A transform that converts rows to packets.

class RowTransform extends _stream.Transform {
  /**
   * @private
   */

  /**
   * @private
   */

  /**
   * @private
   */

  /**
   * @private
   */

  /**
   * @private
   */
  constructor(bulkLoad) {
    super({
      writableObjectMode: true
    });
    this.columnMetadataWritten = void 0;
    this.bulkLoad = void 0;
    this.mainOptions = void 0;
    this.columns = void 0;
    this.bulkLoad = bulkLoad;
    this.mainOptions = bulkLoad.options;
    this.columns = bulkLoad.columns;
    this.columnMetadataWritten = false;
  }
  /**
   * @private
   */


  _transform(row, _encoding, callback) {
    if (!this.columnMetadataWritten) {
      this.push(this.bulkLoad.getColMetaData());
      this.columnMetadataWritten = true;
    }

    this.push(rowTokenBuffer);

    for (let i = 0; i < this.columns.length; i++) {
      const c = this.columns[i];
      let value = Array.isArray(row) ? row[i] : row[c.objName];

      try {
        value = c.type.validate(value, c.collation);
      } catch (error) {
        return callback(error);
      }

      const parameter = {
        length: c.length,
        scale: c.scale,
        precision: c.precision,
        value: value
      };

      if (c.type.name === 'Text' || c.type.name === 'Image' || c.type.name === 'NText') {
        if (value == null) {
          this.push(textPointerNullBuffer);
          continue;
        }

        this.push(textPointerAndTimestampBuffer);
      }

      this.push(c.type.generateParameterLength(parameter, this.mainOptions));

      for (const chunk of c.type.generateParameterData(parameter, this.mainOptions)) {
        this.push(chunk);
      }
    }

    process.nextTick(callback);
  }
  /**
   * @private
   */


  _flush(callback) {
    this.push(this.bulkLoad.createDoneToken());
    process.nextTick(callback);
  }

}
/**
 * A BulkLoad instance is used to perform a bulk insert.
 *
 * Use [[Connection.newBulkLoad]] to create a new instance, and [[Connection.execBulkLoad]] to execute it.
 *
 * Example of BulkLoad Usages:
 *
 * ```js
 * // optional BulkLoad options
 * const options = { keepNulls: true };
 *
 * // instantiate - provide the table where you'll be inserting to, options and a callback
 * const bulkLoad = connection.newBulkLoad('MyTable', options, (error, rowCount) => {
 *   console.log('inserted %d rows', rowCount);
 * });
 *
 * // setup your columns - always indicate whether the column is nullable
 * bulkLoad.addColumn('myInt', TYPES.Int, { nullable: false });
 * bulkLoad.addColumn('myString', TYPES.NVarChar, { length: 50, nullable: true });
 *
 * // execute
 * connection.execBulkLoad(bulkLoad, [
 *   { myInt: 7, myString: 'hello' },
 *   { myInt: 23, myString: 'world' }
 * ]);
 * ```
 */


class BulkLoad extends _events.EventEmitter {
  /**
   * @private
   */

  /**
   * @private
   */

  /**
   * @private
   */

  /**
   * @private
   */

  /**
   * @private
   */

  /**
   * @private
   */

  /**
   * @private
   */

  /**
   * @private
   */

  /**
   * @private
   */

  /**
   * @private
   */

  /**
   * @private
   */

  /**
   * @private
   */

  /**
   * @private
   */

  /**
   * @private
   */

  /**
   * @private
   */

  /**
   * @private
   */

  /**
   * @private
   */

  /**
   * @private
   */
  constructor(table, collation, connectionOptions, {
    checkConstraints = false,
    fireTriggers = false,
    keepNulls = false,
    lockTable = false,
    order = {}
  }, callback) {
    if (typeof checkConstraints !== 'boolean') {
      throw new TypeError('The "options.checkConstraints" property must be of type boolean.');
    }

    if (typeof fireTriggers !== 'boolean') {
      throw new TypeError('The "options.fireTriggers" property must be of type boolean.');
    }

    if (typeof keepNulls !== 'boolean') {
      throw new TypeError('The "options.keepNulls" property must be of type boolean.');
    }

    if (typeof lockTable !== 'boolean') {
      throw new TypeError('The "options.lockTable" property must be of type boolean.');
    }

    if (typeof order !== 'object' || order === null) {
      throw new TypeError('The "options.order" property must be of type object.');
    }

    for (const [column, direction] of Object.entries(order)) {
      if (direction !== 'ASC' && direction !== 'DESC') {
        throw new TypeError('The value of the "' + column + '" key in the "options.order" object must be either "ASC" or "DESC".');
      }
    }

    super();
    this.error = void 0;
    this.canceled = void 0;
    this.executionStarted = void 0;
    this.streamingMode = void 0;
    this.table = void 0;
    this.timeout = void 0;
    this.options = void 0;
    this.callback = void 0;
    this.columns = void 0;
    this.columnsByName = void 0;
    this.firstRowWritten = void 0;
    this.rowToPacketTransform = void 0;
    this.bulkOptions = void 0;
    this.connection = void 0;
    this.rows = void 0;
    this.rst = void 0;
    this.rowCount = void 0;
    this.collation = void 0;
    this.error = undefined;
    this.canceled = false;
    this.executionStarted = false;
    this.collation = collation;
    this.table = table;
    this.options = connectionOptions;
    this.callback = callback;
    this.columns = [];
    this.columnsByName = {};
    this.firstRowWritten = false;
    this.streamingMode = false;
    this.rowToPacketTransform = new RowTransform(this); // eslint-disable-line no-use-before-define

    this.bulkOptions = {
      checkConstraints,
      fireTriggers,
      keepNulls,
      lockTable,
      order
    };
  }
  /**
   * Adds a column to the bulk load.
   *
   * The column definitions should match the table you are trying to insert into.
   * Attempting to call addColumn after the first row has been added will throw an exception.
   *
   * ```js
   * bulkLoad.addColumn('MyIntColumn', TYPES.Int, { nullable: false });
   * ```
   *
   * @param name The name of the column.
   * @param type One of the supported `data types`.
   * @param __namedParameters Additional column type information. At a minimum, `nullable` must be set to true or false.
   * @param length For VarChar, NVarChar, VarBinary. Use length as `Infinity` for VarChar(max), NVarChar(max) and VarBinary(max).
   * @param nullable Indicates whether the column accepts NULL values.
   * @param objName If the name of the column is different from the name of the property found on `rowObj` arguments passed to [[addRow]] or [[Connection.execBulkLoad]], then you can use this option to specify the property name.
   * @param precision For Numeric, Decimal.
   * @param scale For Numeric, Decimal, Time, DateTime2, DateTimeOffset.
  */


  addColumn(name, type, {
    output = false,
    length,
    precision,
    scale,
    objName = name,
    nullable = true
  }) {
    if (this.firstRowWritten) {
      throw new Error('Columns cannot be added to bulk insert after the first row has been written.');
    }

    if (this.executionStarted) {
      throw new Error('Columns cannot be added to bulk insert after execution has started.');
    }

    const column = {
      type: type,
      name: name,
      value: null,
      output: output,
      length: length,
      precision: precision,
      scale: scale,
      objName: objName,
      nullable: nullable,
      collation: this.collation
    };

    if ((type.id & 0x30) === 0x20) {
      if (column.length == null && type.resolveLength) {
        column.length = type.resolveLength(column);
      }
    }

    if (type.resolvePrecision && column.precision == null) {
      column.precision = type.resolvePrecision(column);
    }

    if (type.resolveScale && column.scale == null) {
      column.scale = type.resolveScale(column);
    }

    this.columns.push(column);
    this.columnsByName[name] = column;
  }
  /**
   * Adds a row to the bulk insert.
   *
   * ```js
   * bulkLoad.addRow({ first_name: 'Bill', last_name: 'Gates' });
   * ```
   *
   * @param row An object of key/value pairs representing column name (or objName) and value.
   *
   * @deprecated This method is deprecated. Instead of adding rows individually, you should pass
   *   all row objects when calling [[Connection.execBulkLoad]]. This method will be removed in the future.
   */


  addRow(...input) {
    this.firstRowWritten = true;
    let row;

    if (input.length > 1 || !input[0] || typeof input[0] !== 'object') {
      row = input;
    } else {
      row = input[0];
    } // write each column


    if (Array.isArray(row)) {
      this.rowToPacketTransform.write(this.columns.map((column, i) => {
        return column.type.validate(row[i], column.collation);
      }));
    } else {
      this.rowToPacketTransform.write(this.columns.map(column => {
        return column.type.validate(row[column.objName], column.collation);
      }));
    }
  }
  /**
   * @private
   */


  getOptionsSql() {
    const addOptions = [];

    if (this.bulkOptions.checkConstraints) {
      addOptions.push('CHECK_CONSTRAINTS');
    }

    if (this.bulkOptions.fireTriggers) {
      addOptions.push('FIRE_TRIGGERS');
    }

    if (this.bulkOptions.keepNulls) {
      addOptions.push('KEEP_NULLS');
    }

    if (this.bulkOptions.lockTable) {
      addOptions.push('TABLOCK');
    }

    if (this.bulkOptions.order) {
      const orderColumns = [];

      for (const [column, direction] of Object.entries(this.bulkOptions.order)) {
        orderColumns.push(`${column} ${direction}`);
      }

      if (orderColumns.length) {
        addOptions.push(`ORDER (${orderColumns.join(', ')})`);
      }
    }

    if (addOptions.length > 0) {
      return ` WITH (${addOptions.join(',')})`;
    } else {
      return '';
    }
  }
  /**
   * @private
   */


  getBulkInsertSql() {
    let sql = 'insert bulk ' + this.table + '(';

    for (let i = 0, len = this.columns.length; i < len; i++) {
      const c = this.columns[i];

      if (i !== 0) {
        sql += ', ';
      }

      sql += '[' + c.name + '] ' + c.type.declaration(c);
    }

    sql += ')';
    sql += this.getOptionsSql();
    return sql;
  }
  /**
   * This is simply a helper utility function which returns a `CREATE TABLE SQL` statement based on the columns added to the bulkLoad object.
   * This may be particularly handy when you want to insert into a temporary table (a table which starts with `#`).
   *
   * ```js
   * var sql = bulkLoad.getTableCreationSql();
   * ```
   *
   * A side note on bulk inserting into temporary tables: if you want to access a local temporary table after executing the bulk load,
   * you'll need to use the same connection and execute your requests using [[Connection.execSqlBatch]] instead of [[Connection.execSql]]
   */


  getTableCreationSql() {
    let sql = 'CREATE TABLE ' + this.table + '(\n';

    for (let i = 0, len = this.columns.length; i < len; i++) {
      const c = this.columns[i];

      if (i !== 0) {
        sql += ',\n';
      }

      sql += '[' + c.name + '] ' + c.type.declaration(c);

      if (c.nullable !== undefined) {
        sql += ' ' + (c.nullable ? 'NULL' : 'NOT NULL');
      }
    }

    sql += '\n)';
    return sql;
  }
  /**
   * @private
   */


  getColMetaData() {
    const tBuf = new _writableTrackingBuffer.default(100, null, true); // TokenType

    tBuf.writeUInt8(_token.TYPE.COLMETADATA); // Count

    tBuf.writeUInt16LE(this.columns.length);

    for (let j = 0, len = this.columns.length; j < len; j++) {
      const c = this.columns[j]; // UserType

      if (this.options.tdsVersion < '7_2') {
        tBuf.writeUInt16LE(0);
      } else {
        tBuf.writeUInt32LE(0);
      } // Flags


      let flags = FLAGS.updateableReadWrite;

      if (c.nullable) {
        flags |= FLAGS.nullable;
      } else if (c.nullable === undefined && this.options.tdsVersion >= '7_2') {
        flags |= FLAGS.nullableUnknown;
      }

      tBuf.writeUInt16LE(flags); // TYPE_INFO

      tBuf.writeBuffer(c.type.generateTypeInfo(c, this.options)); // TableName

      if (c.type.hasTableName) {
        tBuf.writeUsVarchar(this.table, 'ucs2');
      } // ColName


      tBuf.writeBVarchar(c.name, 'ucs2');
    }

    return tBuf.data;
  }
  /**
   * Sets a timeout for this bulk load.
   *
   * ```js
   * bulkLoad.setTimeout(timeout);
   * ```
   *
   * @param timeout The number of milliseconds before the bulk load is considered failed, or 0 for no timeout.
   *   When no timeout is set for the bulk load, the [[ConnectionOptions.requestTimeout]] of the Connection is used.
   */


  setTimeout(timeout) {
    this.timeout = timeout;
  }
  /**
   * @private
   */


  createDoneToken() {
    // It might be nice to make DoneToken a class if anything needs to create them, but for now, just do it here
    const tBuf = new _writableTrackingBuffer.default(this.options.tdsVersion < '7_2' ? 9 : 13);
    tBuf.writeUInt8(_token.TYPE.DONE);
    const status = DONE_STATUS.FINAL;
    tBuf.writeUInt16LE(status);
    tBuf.writeUInt16LE(0); // CurCmd (TDS ignores this)

    tBuf.writeUInt32LE(0); // row count - doesn't really matter

    if (this.options.tdsVersion >= '7_2') {
      tBuf.writeUInt32LE(0); // row count is 64 bits in >= TDS 7.2
    }

    return tBuf.data;
  }
  /**
   * Switches the `BulkLoad` object into streaming mode and returns a
   * [writable stream](https://nodejs.org/dist/latest-v10.x/docs/api/stream.html#stream_writable_streams)
   * that can be used to send a large amount of rows to the server.
   *
   * ```js
   * const bulkLoad = connection.newBulkLoad(...);
   * bulkLoad.addColumn(...);
   *
   * const rowStream = bulkLoad.getRowStream();
   *
   * connection.execBulkLoad(bulkLoad);
   * ```
   *
   * In streaming mode, [[addRow]] cannot be used. Instead all data rows must be written to the returned stream object.
   * The stream implementation uses data flow control to prevent memory overload. [`stream.write()`](https://nodejs.org/dist/latest-v10.x/docs/api/stream.html#stream_writable_write_chunk_encoding_callback)
   * returns `false` to indicate that data transfer should be paused.
   *
   * After that, the stream emits a ['drain' event](https://nodejs.org/dist/latest-v10.x/docs/api/stream.html#stream_event_drain)
   * when it is ready to resume data transfer.
   *
   * @deprecated
   *   This method is deprecated. Instead of writing rows to the stream returned by this method,
   *   you can pass any object that implements the `Iterable` or `AsyncIterable` interface (e.g. a `Readable`
   *   stream or an `AsyncGenerator`) when calling [[Connection.execBulkLoad]]. This method will be removed in the future.
   */


  getRowStream() {
    if (this.firstRowWritten) {
      throw new Error('BulkLoad cannot be switched to streaming mode after first row has been written using addRow().');
    }

    if (this.executionStarted) {
      throw new Error('BulkLoad cannot be switched to streaming mode after execution has started.');
    }

    this.streamingMode = true;
    return this.rowToPacketTransform;
  }
  /**
   * @private
   */


  cancel() {
    if (this.canceled) {
      return;
    }

    this.canceled = true;
    this.emit('cancel');
  }

}

var _default = BulkLoad;
exports.default = _default;
module.exports = BulkLoad;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9idWxrLWxvYWQudHMiXSwibmFtZXMiOlsiRkxBR1MiLCJudWxsYWJsZSIsImNhc2VTZW4iLCJ1cGRhdGVhYmxlUmVhZFdyaXRlIiwidXBkYXRlYWJsZVVua25vd24iLCJpZGVudGl0eSIsImNvbXB1dGVkIiwiZml4ZWRMZW5DTFJUeXBlIiwic3BhcnNlQ29sdW1uU2V0IiwiaGlkZGVuIiwia2V5IiwibnVsbGFibGVVbmtub3duIiwiRE9ORV9TVEFUVVMiLCJGSU5BTCIsIk1PUkUiLCJFUlJPUiIsIklOWEFDVCIsIkNPVU5UIiwiQVRUTiIsIlNSVkVSUk9SIiwicm93VG9rZW5CdWZmZXIiLCJCdWZmZXIiLCJmcm9tIiwiVE9LRU5fVFlQRSIsIlJPVyIsInRleHRQb2ludGVyQW5kVGltZXN0YW1wQnVmZmVyIiwidGV4dFBvaW50ZXJOdWxsQnVmZmVyIiwiUm93VHJhbnNmb3JtIiwiVHJhbnNmb3JtIiwiY29uc3RydWN0b3IiLCJidWxrTG9hZCIsIndyaXRhYmxlT2JqZWN0TW9kZSIsImNvbHVtbk1ldGFkYXRhV3JpdHRlbiIsIm1haW5PcHRpb25zIiwiY29sdW1ucyIsIm9wdGlvbnMiLCJfdHJhbnNmb3JtIiwicm93IiwiX2VuY29kaW5nIiwiY2FsbGJhY2siLCJwdXNoIiwiZ2V0Q29sTWV0YURhdGEiLCJpIiwibGVuZ3RoIiwiYyIsInZhbHVlIiwiQXJyYXkiLCJpc0FycmF5Iiwib2JqTmFtZSIsInR5cGUiLCJ2YWxpZGF0ZSIsImNvbGxhdGlvbiIsImVycm9yIiwicGFyYW1ldGVyIiwic2NhbGUiLCJwcmVjaXNpb24iLCJuYW1lIiwiZ2VuZXJhdGVQYXJhbWV0ZXJMZW5ndGgiLCJjaHVuayIsImdlbmVyYXRlUGFyYW1ldGVyRGF0YSIsInByb2Nlc3MiLCJuZXh0VGljayIsIl9mbHVzaCIsImNyZWF0ZURvbmVUb2tlbiIsIkJ1bGtMb2FkIiwiRXZlbnRFbWl0dGVyIiwidGFibGUiLCJjb25uZWN0aW9uT3B0aW9ucyIsImNoZWNrQ29uc3RyYWludHMiLCJmaXJlVHJpZ2dlcnMiLCJrZWVwTnVsbHMiLCJsb2NrVGFibGUiLCJvcmRlciIsIlR5cGVFcnJvciIsImNvbHVtbiIsImRpcmVjdGlvbiIsIk9iamVjdCIsImVudHJpZXMiLCJjYW5jZWxlZCIsImV4ZWN1dGlvblN0YXJ0ZWQiLCJzdHJlYW1pbmdNb2RlIiwidGltZW91dCIsImNvbHVtbnNCeU5hbWUiLCJmaXJzdFJvd1dyaXR0ZW4iLCJyb3dUb1BhY2tldFRyYW5zZm9ybSIsImJ1bGtPcHRpb25zIiwiY29ubmVjdGlvbiIsInJvd3MiLCJyc3QiLCJyb3dDb3VudCIsInVuZGVmaW5lZCIsImFkZENvbHVtbiIsIm91dHB1dCIsIkVycm9yIiwiaWQiLCJyZXNvbHZlTGVuZ3RoIiwicmVzb2x2ZVByZWNpc2lvbiIsInJlc29sdmVTY2FsZSIsImFkZFJvdyIsImlucHV0Iiwid3JpdGUiLCJtYXAiLCJnZXRPcHRpb25zU3FsIiwiYWRkT3B0aW9ucyIsIm9yZGVyQ29sdW1ucyIsImpvaW4iLCJnZXRCdWxrSW5zZXJ0U3FsIiwic3FsIiwibGVuIiwiZGVjbGFyYXRpb24iLCJnZXRUYWJsZUNyZWF0aW9uU3FsIiwidEJ1ZiIsIldyaXRhYmxlVHJhY2tpbmdCdWZmZXIiLCJ3cml0ZVVJbnQ4IiwiQ09MTUVUQURBVEEiLCJ3cml0ZVVJbnQxNkxFIiwiaiIsInRkc1ZlcnNpb24iLCJ3cml0ZVVJbnQzMkxFIiwiZmxhZ3MiLCJ3cml0ZUJ1ZmZlciIsImdlbmVyYXRlVHlwZUluZm8iLCJoYXNUYWJsZU5hbWUiLCJ3cml0ZVVzVmFyY2hhciIsIndyaXRlQlZhcmNoYXIiLCJkYXRhIiwic2V0VGltZW91dCIsIkRPTkUiLCJzdGF0dXMiLCJnZXRSb3dTdHJlYW0iLCJjYW5jZWwiLCJlbWl0IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOztBQUNBOztBQUdBOztBQUNBOzs7O0FBS0E7QUFDQTtBQUNBO0FBQ0EsTUFBTUEsS0FBSyxHQUFHO0FBQ1pDLEVBQUFBLFFBQVEsRUFBRSxL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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNFSSxFQUFBQSxZQUFZLEdBQUc7QUFDYixRQUFJLEtBQUs5QyxlQUFULEVBQTBCO0FBQ3hCLFlBQU0sSUFBSVUsS0FBSixDQUFVLGdHQUFWLENBQU47QUFDRDs7QUFDRCxRQUFJLEtBQUtkLGdCQUFULEVBQTJCO0FBQ3pCLFlBQU0sSUFBSWMsS0FBSixDQUFVLDRFQUFWLENBQU47QUFDRDs7QUFDRCxTQUFLYixhQUFMLEdBQXFCLElBQXJCO0FBRUEsV0FBTyxLQUFLSSxvQkFBWjtBQUNEO0FBRUQ7QUFDRjtBQUNBOzs7QUFDRThDLEVBQUFBLE1BQU0sR0FBRztBQUNQLFFBQUksS0FBS3BELFFBQVQsRUFBbUI7QUFDakI7QUFDRDs7QUFFRCxTQUFLQSxRQUFMLEdBQWdCLElBQWhCO0FBQ0EsU0FBS3FELElBQUwsQ0FBVSxRQUFWO0FBQ0Q7O0FBamRpQzs7ZUFvZHJCbkUsUTs7QUFDZm9FLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQnJFLFFBQWpCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnZXZlbnRzJztcbmltcG9ydCBXcml0YWJsZVRyYWNraW5nQnVmZmVyIGZyb20gJy4vdHJhY2tpbmctYnVmZmVyL3dyaXRhYmxlLXRyYWNraW5nLWJ1ZmZlcic7XG5pbXBvcnQgQ29ubmVjdGlvbiwgeyBJbnRlcm5hbENvbm5lY3Rpb25PcHRpb25zIH0gZnJvbSAnLi9jb25uZWN0aW9uJztcblxuaW1wb3J0IHsgVHJhbnNmb3JtIH0gZnJvbSAnc3RyZWFtJztcbmltcG9ydCB7IFRZUEUgYXMgVE9LRU5fVFlQRSB9IGZyb20gJy4vdG9rZW4vdG9rZW4nO1xuXG5pbXBvcnQgeyBEYXRhVHlwZSwgUGFyYW1ldGVyIH0gZnJvbSAnLi9kYXRhLXR5cGUnO1xuaW1wb3J0IHsgQ29sbGF0aW9uIH0gZnJvbSAnLi9jb2xsYXRpb24nO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IEZMQUdTID0ge1xuICBudWxsYWJsZTogMSA8PCAwLFxuICBjYXNlU2VuOiAxIDw8IDEsXG4gIHVwZGF0ZWFibGVSZWFkV3JpdGU6IDEgPDwgMixcbiAgdXBkYXRlYWJsZVVua25vd246IDEgPDwgMyxcbiAgaWRlbnRpdHk6IDEgPDwgNCxcbiAgY29tcHV0ZWQ6IDEgPDwgNSwgLy8gaW50cm9kdWNlZCBpbiBURFMgNy4yXG4gIGZpeGVkTGVuQ0xSVHlwZTogMSA8PCA4LCAvLyBpbnRyb2R1Y2VkIGluIFREUyA3LjJcbiAgc3BhcnNlQ29sdW1uU2V0OiAxIDw8IDEwLCAvLyBpbnRyb2R1Y2VkIGluIFREUyA3LjMuQlxuICBoaWRkZW46IDEgPDwgMTMsIC8vIGludHJvZHVjZWQgaW4gVERTIDcuMlxuICBrZXk6IDEgPDwgMTQsIC8vIGludHJvZHVjZWQgaW4gVERTIDcuMlxuICBudWxsYWJsZVVua25vd246IDEgPDwgMTUgLy8gaW50cm9kdWNlZCBpbiBURFMgNy4yXG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IERPTkVfU1RBVFVTID0ge1xuICBGSU5BTDogMHgwMCxcbiAgTU9SRTogMHgxLFxuICBFUlJPUjogMHgyLFxuICBJTlhBQ1Q6IDB4NCxcbiAgQ09VTlQ6IDB4MTAsXG4gIEFUVE46IDB4MjAsXG4gIFNSVkVSUk9SOiAweDEwMFxufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5pbnRlcmZhY2UgSW50ZXJuYWxPcHRpb25zIHtcbiAgY2hlY2tDb25zdHJhaW50czogYm9vbGVhbjtcbiAgZmlyZVRyaWdnZXJzOiBib29sZWFuO1xuICBrZWVwTnVsbHM6IGJvb2xlYW47XG4gIGxvY2tUYWJsZTogYm9vbGVhbjtcbiAgb3JkZXI6IHsgW2NvbHVtbk5hbWU6IHN0cmluZ106ICdBU0MnIHwgJ0RFU0MnIH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBIb25vcnMgY29uc3RyYWludHMgZHVyaW5nIGJ1bGsgbG9hZCwgdXNpbmcgVC1TUUxcbiAgICogW0NIRUNLX0NPTlNUUkFJTlRTXShodHRwczovL3RlY2huZXQubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zMTg2MjQ3KHY9c3FsLjEwNSkuYXNweCkuXG4gICAqIChkZWZhdWx0OiBgZmFsc2VgKVxuICAgKi9cbiAgY2hlY2tDb25zdHJhaW50cz86IEludGVybmFsT3B0aW9uc1snY2hlY2tDb25zdHJhaW50cyddIHwgdW5kZWZpbmVkO1xuXG4gIC8qKlxuICAgKiBIb25vcnMgaW5zZXJ0IHRyaWdnZXJzIGR1cmluZyBidWxrIGxvYWQsIHVzaW5nIHRoZSBULVNRTCBbRklSRV9UUklHR0VSU10oaHR0cHM6Ly90ZWNobmV0Lm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczE4NzY0MCh2PXNxbC4xMDUpLmFzcHgpLiAoZGVmYXVsdDogYGZhbHNlYClcbiAgICovXG4gIGZpcmVUcmlnZ2Vycz86IEludGVybmFsT3B0aW9uc1snZmlyZVRyaWdnZXJzJ10gfCB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIEhvbm9ycyBudWxsIHZhbHVlIHBhc3NlZCwgaWdub3JlcyB0aGUgZGVmYXVsdCB2YWx1ZXMgc2V0IG9uIHRhYmxlLCB1c2luZyBULVNRTCBbS0VFUF9OVUxMU10oaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczE4Nzg4Nyh2PXNxbC4xMjApLmFzcHgpLiAoZGVmYXVsdDogYGZhbHNlYClcbiAgICovXG4gIGtlZXBOdWxscz86IEludGVybmFsT3B0aW9uc1sna2VlcE51bGxzJ10gfCB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIFBsYWNlcyBhIGJ1bGsgdXBkYXRlKEJVKSBsb2NrIG9uIHRhYmxlIHdoaWxlIHBlcmZvcm1pbmcgYnVsayBsb2FkLCB1c2luZyBULVNRTCBbVEFCTE9DS10oaHR0cHM6Ly90ZWNobmV0Lm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczE4MDg3Nih2PXNxbC4xMDUpLmFzcHgpLiAoZGVmYXVsdDogYGZhbHNlYClcbiAgICovXG4gIGxvY2tUYWJsZT86IEludGVybmFsT3B0aW9uc1snbG9ja1RhYmxlJ10gfCB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIFNwZWNpZmllcyB0aGUgb3JkZXJpbmcgb2YgdGhlIGRhdGEgdG8gcG9zc2libHkgaW5jcmVhc2UgYnVsayBpbnNlcnQgcGVyZm9ybWFuY2UsIHVzaW5nIFQtU1FMIFtPUkRFUl0oaHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tdXMvcHJldmlvdXMtdmVyc2lvbnMvc3FsL3NxbC1zZXJ2ZXItMjAwOC1yMi9tczE3NzQ2OCh2PXNxbC4xMDUpKS4gKGRlZmF1bHQ6IGB7fWApXG4gICAqL1xuICBvcmRlcj86IEludGVybmFsT3B0aW9uc1snb3JkZXInXSB8IHVuZGVmaW5lZDtcbn1cblxuXG5leHBvcnQgdHlwZSBDYWxsYmFjayA9XG4gIC8qKlxuICAgKiBBIGZ1bmN0aW9uIHdoaWNoIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRoZSBbW0J1bGtMb2FkXV0gZmluaXNoZXMgZXhlY3V0aW5nLlxuICAgKlxuICAgKiBAcGFyYW0gcm93Q291bnQgdGhlIG51bWJlciBvZiByb3dzIGluc2VydGVkXG4gICAqL1xuICAoZXJyOiBFcnJvciB8IHVuZGVmaW5lZCB8IG51bGwsIHJvd0NvdW50PzogbnVtYmVyKSA9PiB2b2lkO1xuXG5pbnRlcmZhY2UgQ29sdW1uIGV4dGVuZHMgUGFyYW1ldGVyIHtcbiAgb2JqTmFtZTogc3RyaW5nO1xuICBjb2xsYXRpb246IENvbGxhdGlvbiB8IHVuZGVmaW5lZDtcbn1cblxuaW50ZXJmYWNlIENvbHVtbk9wdGlvbnMge1xuICBvdXRwdXQ/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBGb3IgVmFyQ2hhciwgTlZhckNoYXIsIFZhckJpbmFyeS4gVXNlIGxlbmd0aCBhcyBgSW5maW5pdHlgIGZvciBWYXJDaGFyKG1heCksIE5WYXJDaGFyKG1heCkgYW5kIFZhckJpbmFyeShtYXgpLlxuICAgKi9cbiAgbGVuZ3RoPzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBGb3IgTnVtZXJpYywgRGVjaW1hbC5cbiAgICovXG4gIHByZWNpc2lvbj86IG51bWJlcjtcblxuICAvKipcbiAgICogRm9yIE51bWVyaWMsIERlY2ltYWwsIFRpbWUsIERhdGVUaW1lMiwgRGF0ZVRpbWVPZmZzZXQuXG4gICAqL1xuICBzY2FsZT86IG51bWJlcjtcblxuICAvKipcbiAgICogSWYgdGhlIG5hbWUgb2YgdGhlIGNvbHVtbiBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgZm91bmQgb24gYHJvd09iamAgYXJndW1lbnRzIHBhc3NlZCB0byBbW2FkZFJvd11dLCB0aGVuIHlvdSBjYW4gdXNlIHRoaXMgb3B0aW9uIHRvIHNwZWNpZnkgdGhlIHByb3BlcnR5IG5hbWUuXG4gICAqL1xuICBvYmpOYW1lPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgY29sdW1uIGFjY2VwdHMgTlVMTCB2YWx1ZXMuXG4gICAqL1xuICBudWxsYWJsZT86IGJvb2xlYW47XG59XG5cbmNvbnN0IHJvd1Rva2VuQnVmZmVyID0gQnVmZmVyLmZyb20oWyBUT0tFTl9UWVBFLlJPVyBdKTtcbmNvbnN0IHRleHRQb2ludGVyQW5kVGltZXN0YW1wQnVmZmVyID0gQnVmZmVyLmZyb20oW1xuICAvLyBUZXh0UG9pbnRlciBsZW5ndGhcbiAgMHgxMCxcblxuICAvLyBUZXh0UG9pbnRlclxuICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuXG4gIC8vIFRpbWVzdGFtcFxuICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwXG5dKTtcbmNvbnN0IHRleHRQb2ludGVyTnVsbEJ1ZmZlciA9IEJ1ZmZlci5mcm9tKFsweDAwXSk7XG5cbi8vIEEgdHJhbnNmb3JtIHRoYXQgY29udmVydHMgcm93cyB0byBwYWNrZXRzLlxuY2xhc3MgUm93VHJhbnNmb3JtIGV4dGVuZHMgVHJhbnNmb3JtIHtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb2x1bW5NZXRhZGF0YVdyaXR0ZW46IGJvb2xlYW47XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYnVsa0xvYWQ6IEJ1bGtMb2FkO1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIG1haW5PcHRpb25zOiBCdWxrTG9hZFsnb3B0aW9ucyddO1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbHVtbnM6IEJ1bGtMb2FkWydjb2x1bW5zJ107XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb25zdHJ1Y3RvcihidWxrTG9hZDogQnVsa0xvYWQpIHtcbiAgICBzdXBlcih7IHdyaXRhYmxlT2JqZWN0TW9kZTogdHJ1ZSB9KTtcblxuICAgIHRoaXMuYnVsa0xvYWQgPSBidWxrTG9hZDtcbiAgICB0aGlzLm1haW5PcHRpb25zID0gYnVsa0xvYWQub3B0aW9ucztcbiAgICB0aGlzLmNvbHVtbnMgPSBidWxrTG9hZC5jb2x1bW5zO1xuXG4gICAgdGhpcy5jb2x1bW5NZXRhZGF0YVdyaXR0ZW4gPSBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3RyYW5zZm9ybShyb3c6IEFycmF5PHVua25vd24+IHwgeyBbY29sTmFtZTogc3RyaW5nXTogdW5rbm93biB9LCBfZW5jb2Rpbmc6IHN0cmluZywgY2FsbGJhY2s6IChlcnJvcj86IEVycm9yKSA9PiB2b2lkKSB7XG4gICAgaWYgKCF0aGlzLmNvbHVtbk1ldGFkYXRhV3JpdHRlbikge1xuICAgICAgdGhpcy5wdXNoKHRoaXMuYnVsa0xvYWQuZ2V0Q29sTWV0YURhdGEoKSk7XG4gICAgICB0aGlzLmNvbHVtbk1ldGFkYXRhV3JpdHRlbiA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5wdXNoKHJvd1Rva2VuQnVmZmVyKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jb2x1bW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjID0gdGhpcy5jb2x1bW5zW2ldO1xuICAgICAgbGV0IHZhbHVlID0gQXJyYXkuaXNBcnJheShyb3cpID8gcm93W2ldIDogcm93W2Mub2JqTmFtZV07XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHZhbHVlID0gYy50eXBlLnZhbGlkYXRlKHZhbHVlLCBjLmNvbGxhdGlvbik7XG4gICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnJvcik7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBhcmFtZXRlciA9IHtcbiAgICAgICAgbGVuZ3RoOiBjLmxlbmd0aCxcbiAgICAgICAgc2NhbGU6IGMuc2NhbGUsXG4gICAgICAgIHByZWNpc2lvbjogYy5wcmVjaXNpb24sXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfTtcblxuICAgICAgaWYgKGMudHlwZS5uYW1lID09PSAnVGV4dCcgfHwgYy50eXBlLm5hbWUgPT09ICdJbWFnZScgfHwgYy50eXBlLm5hbWUgPT09ICdOVGV4dCcpIHtcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLnB1c2godGV4dFBvaW50ZXJOdWxsQnVmZmVyKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucHVzaCh0ZXh0UG9pbnRlckFuZFRpbWVzdGFtcEJ1ZmZlcik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucHVzaChjLnR5cGUuZ2VuZXJhdGVQYXJhbWV0ZXJMZW5ndGgocGFyYW1ldGVyLCB0aGlzLm1haW5PcHRpb25zKSk7XG4gICAgICBmb3IgKGNvbnN0IGNodW5rIG9mIGMudHlwZS5nZW5lcmF0ZVBhcmFtZXRlckRhdGEocGFyYW1ldGVyLCB0aGlzLm1haW5PcHRpb25zKSkge1xuICAgICAgICB0aGlzLnB1c2goY2h1bmspO1xuICAgICAgfVxuICAgIH1cblxuICAgIHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZmx1c2goY2FsbGJhY2s6ICgpID0+IHZvaWQpIHtcbiAgICB0aGlzLnB1c2godGhpcy5idWxrTG9hZC5jcmVhdGVEb25lVG9rZW4oKSk7XG5cbiAgICBwcm9jZXNzLm5leHRUaWNrKGNhbGxiYWNrKTtcbiAgfVxufVxuXG4vKipcbiAqIEEgQnVsa0xvYWQgaW5zdGFuY2UgaXMgdXNlZCB0byBwZXJmb3JtIGEgYnVsayBpbnNlcnQuXG4gKlxuICogVXNlIFtbQ29ubmVjdGlvbi5uZXdCdWxrTG9hZF1dIHRvIGNyZWF0ZSBhIG5ldyBpbnN0YW5jZSwgYW5kIFtbQ29ubmVjdGlvbi5leGVjQnVsa0xvYWRdXSB0byBleGVjdXRlIGl0LlxuICpcbiAqIEV4YW1wbGUgb2YgQnVsa0xvYWQgVXNhZ2VzOlxuICpcbiAqIGBgYGpzXG4gKiAvLyBvcHRpb25hbCBCdWxrTG9hZCBvcHRpb25zXG4gKiBjb25zdCBvcHRpb25zID0geyBrZWVwTnVsbHM6IHRydWUgfTtcbiAqXG4gKiAvLyBpbnN0YW50aWF0ZSAtIHByb3ZpZGUgdGhlIHRhYmxlIHdoZXJlIHlvdSdsbCBiZSBpbnNlcnRpbmcgdG8sIG9wdGlvbnMgYW5kIGEgY2FsbGJhY2tcbiAqIGNvbnN0IGJ1bGtMb2FkID0gY29ubmVjdGlvbi5uZXdCdWxrTG9hZCgnTXlUYWJsZScsIG9wdGlvbnMsIChlcnJvciwgcm93Q291bnQpID0+IHtcbiAqICAgY29uc29sZS5sb2coJ2luc2VydGVkICVkIHJvd3MnLCByb3dDb3VudCk7XG4gKiB9KTtcbiAqXG4gKiAvLyBzZXR1cCB5b3VyIGNvbHVtbnMgLSBhbHdheXMgaW5kaWNhdGUgd2hldGhlciB0aGUgY29sdW1uIGlzIG51bGxhYmxlXG4gKiBidWxrTG9hZC5hZGRDb2x1bW4oJ215SW50JywgVFlQRVMuSW50LCB7IG51bGxhYmxlOiBmYWxzZSB9KTtcbiAqIGJ1bGtMb2FkLmFkZENvbHVtbignbXlTdHJpbmcnLCBUWVBFUy5OVmFyQ2hhciwgeyBsZW5ndGg6IDUwLCBudWxsYWJsZTogdHJ1ZSB9KTtcbiAqXG4gKiAvLyBleGVjdXRlXG4gKiBjb25uZWN0aW9uLmV4ZWNCdWxrTG9hZChidWxrTG9hZCwgW1xuICogICB7IG15SW50OiA3LCBteVN0cmluZzogJ2hlbGxvJyB9LFxuICogICB7IG15SW50OiAyMywgbXlTdHJpbmc6ICd3b3JsZCcgfVxuICogXSk7XG4gKiBgYGBcbiAqL1xuY2xhc3MgQnVsa0xvYWQgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGVycm9yOiBFcnJvciB8IHVuZGVmaW5lZDtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjYW5jZWxlZDogYm9vbGVhbjtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBleGVjdXRpb25TdGFydGVkOiBib29sZWFuO1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN0cmVhbWluZ01vZGU6IGJvb2xlYW47XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGFibGU6IHN0cmluZztcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aW1lb3V0OiBudW1iZXIgfCB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBvcHRpb25zOiBJbnRlcm5hbENvbm5lY3Rpb25PcHRpb25zO1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNhbGxiYWNrOiBDYWxsYmFjaztcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbHVtbnM6IEFycmF5PENvbHVtbj47XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29sdW1uc0J5TmFtZTogeyBbbmFtZTogc3RyaW5nXTogQ29sdW1uIH07XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmaXJzdFJvd1dyaXR0ZW46IGJvb2xlYW47XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcm93VG9QYWNrZXRUcmFuc2Zvcm06IFJvd1RyYW5zZm9ybTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGJ1bGtPcHRpb25zOiBJbnRlcm5hbE9wdGlvbnM7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb25uZWN0aW9uOiBDb25uZWN0aW9uIHwgdW5kZWZpbmVkO1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJvd3M6IEFycmF5PGFueT4gfCB1bmRlZmluZWQ7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcnN0OiBBcnJheTxhbnk+IHwgdW5kZWZpbmVkO1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJvd0NvdW50OiBudW1iZXIgfCB1bmRlZmluZWQ7XG5cbiAgY29sbGF0aW9uOiBDb2xsYXRpb24gfCB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0YWJsZTogc3RyaW5nLCBjb2xsYXRpb246IENvbGxhdGlvbiB8IHVuZGVmaW5lZCwgY29ubmVjdGlvbk9wdGlvbnM6IEludGVybmFsQ29ubmVjdGlvbk9wdGlvbnMsIHtcbiAgICBjaGVja0NvbnN0cmFpbnRzID0gZmFsc2UsXG4gICAgZmlyZVRyaWdnZXJzID0gZmFsc2UsXG4gICAga2VlcE51bGxzID0gZmFsc2UsXG4gICAgbG9ja1RhYmxlID0gZmFsc2UsXG4gICAgb3JkZXIgPSB7fSxcbiAgfTogT3B0aW9ucywgY2FsbGJhY2s6IENhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBjaGVja0NvbnN0cmFpbnRzICE9PSAnYm9vbGVhbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcIm9wdGlvbnMuY2hlY2tDb25zdHJhaW50c1wiIHByb3BlcnR5IG11c3QgYmUgb2YgdHlwZSBib29sZWFuLicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZmlyZVRyaWdnZXJzICE9PSAnYm9vbGVhbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcIm9wdGlvbnMuZmlyZVRyaWdnZXJzXCIgcHJvcGVydHkgbXVzdCBiZSBvZiB0eXBlIGJvb2xlYW4uJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBrZWVwTnVsbHMgIT09ICdib29sZWFuJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwib3B0aW9ucy5rZWVwTnVsbHNcIiBwcm9wZXJ0eSBtdXN0IGJlIG9mIHR5cGUgYm9vbGVhbi4nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGxvY2tUYWJsZSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJvcHRpb25zLmxvY2tUYWJsZVwiIHByb3BlcnR5IG11c3QgYmUgb2YgdHlwZSBib29sZWFuLicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb3JkZXIgIT09ICdvYmplY3QnIHx8IG9yZGVyID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJvcHRpb25zLm9yZGVyXCIgcHJvcGVydHkgbXVzdCBiZSBvZiB0eXBlIG9iamVjdC4nKTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IFtjb2x1bW4sIGRpcmVjdGlvbl0gb2YgT2JqZWN0LmVudHJpZXMob3JkZXIpKSB7XG4gICAgICBpZiAoZGlyZWN0aW9uICE9PSAnQVNDJyAmJiBkaXJlY3Rpb24gIT09ICdERVNDJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgdmFsdWUgb2YgdGhlIFwiJyArIGNvbHVtbiArICdcIiBrZXkgaW4gdGhlIFwib3B0aW9ucy5vcmRlclwiIG9iamVjdCBtdXN0IGJlIGVpdGhlciBcIkFTQ1wiIG9yIFwiREVTQ1wiLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLmVycm9yID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY2FuY2VsZWQgPSBmYWxzZTtcbiAgICB0aGlzLmV4ZWN1dGlvblN0YXJ0ZWQgPSBmYWxzZTtcblxuICAgIHRoaXMuY29sbGF0aW9uID0gY29sbGF0aW9uO1xuXG4gICAgdGhpcy50YWJsZSA9IHRhYmxlO1xuICAgIHRoaXMub3B0aW9ucyA9IGNvbm5lY3Rpb25PcHRpb25zO1xuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB0aGlzLmNvbHVtbnMgPSBbXTtcbiAgICB0aGlzLmNvbHVtbnNCeU5hbWUgPSB7fTtcbiAgICB0aGlzLmZpcnN0Um93V3JpdHRlbiA9IGZhbHNlO1xuICAgIHRoaXMuc3RyZWFtaW5nTW9kZSA9IGZhbHNlO1xuXG4gICAgdGhpcy5yb3dUb1BhY2tldFRyYW5zZm9ybSA9IG5ldyBSb3dUcmFuc2Zvcm0odGhpcyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdXNlLWJlZm9yZS1kZWZpbmVcblxuICAgIHRoaXMuYnVsa09wdGlvbnMgPSB7IGNoZWNrQ29uc3RyYWludHMsIGZpcmVUcmlnZ2Vycywga2VlcE51bGxzLCBsb2NrVGFibGUsIG9yZGVyIH07XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIGNvbHVtbiB0byB0aGUgYnVsayBsb2FkLlxuICAgKlxuICAgKiBUaGUgY29sdW1uIGRlZmluaXRpb25zIHNob3VsZCBtYXRjaCB0aGUgdGFibGUgeW91IGFyZSB0cnlpbmcgdG8gaW5zZXJ0IGludG8uXG4gICAqIEF0dGVtcHRpbmcgdG8gY2FsbCBhZGRDb2x1bW4gYWZ0ZXIgdGhlIGZpcnN0IHJvdyBoYXMgYmVlbiBhZGRlZCB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbi5cbiAgICpcbiAgICogYGBganNcbiAgICogYnVsa0xvYWQuYWRkQ29sdW1uKCdNeUludENvbHVtbicsIFRZUEVTLkludCwgeyBudWxsYWJsZTogZmFsc2UgfSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgY29sdW1uLlxuICAgKiBAcGFyYW0gdHlwZSBPbmUgb2YgdGhlIHN1cHBvcnRlZCBgZGF0YSB0eXBlc2AuXG4gICAqIEBwYXJhbSBfX25hbWVkUGFyYW1ldGVycyBBZGRpdGlvbmFsIGNvbHVtbiB0eXBlIGluZm9ybWF0aW9uLiBBdCBhIG1pbmltdW0sIGBudWxsYWJsZWAgbXVzdCBiZSBzZXQgdG8gdHJ1ZSBvciBmYWxzZS5cbiAgICogQHBhcmFtIGxlbmd0aCBGb3IgVmFyQ2hhciwgTlZhckNoYXIsIFZhckJpbmFyeS4gVXNlIGxlbmd0aCBhcyBgSW5maW5pdHlgIGZvciBWYXJDaGFyKG1heCksIE5WYXJDaGFyKG1heCkgYW5kIFZhckJpbmFyeShtYXgpLlxuICAgKiBAcGFyYW0gbnVsbGFibGUgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGNvbHVtbiBhY2NlcHRzIE5VTEwgdmFsdWVzLlxuICAgKiBAcGFyYW0gb2JqTmFtZSBJZiB0aGUgbmFtZSBvZiB0aGUgY29sdW1uIGlzIGRpZmZlcmVudCBmcm9tIHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSBmb3VuZCBvbiBgcm93T2JqYCBhcmd1bWVudHMgcGFzc2VkIHRvIFtbYWRkUm93XV0gb3IgW1tDb25uZWN0aW9uLmV4ZWNCdWxrTG9hZF1dLCB0aGVuIHlvdSBjYW4gdXNlIHRoaXMgb3B0aW9uIHRvIHNwZWNpZnkgdGhlIHByb3BlcnR5IG5hbWUuXG4gICAqIEBwYXJhbSBwcmVjaXNpb24gRm9yIE51bWVyaWMsIERlY2ltYWwuXG4gICAqIEBwYXJhbSBzY2FsZSBGb3IgTnVtZXJpYywgRGVjaW1hbCwgVGltZSwgRGF0ZVRpbWUyLCBEYXRlVGltZU9mZnNldC5cbiAgKi9cbiAgYWRkQ29sdW1uKG5hbWU6IHN0cmluZywgdHlwZTogRGF0YVR5cGUsIHsgb3V0cHV0ID0gZmFsc2UsIGxlbmd0aCwgcHJlY2lzaW9uLCBzY2FsZSwgb2JqTmFtZSA9IG5hbWUsIG51bGxhYmxlID0gdHJ1ZSB9OiBDb2x1bW5PcHRpb25zKSB7XG4gICAgaWYgKHRoaXMuZmlyc3RSb3dXcml0dGVuKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbHVtbnMgY2Fubm90IGJlIGFkZGVkIHRvIGJ1bGsgaW5zZXJ0IGFmdGVyIHRoZSBmaXJzdCByb3cgaGFzIGJlZW4gd3JpdHRlbi4nKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZXhlY3V0aW9uU3RhcnRlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb2x1bW5zIGNhbm5vdCBiZSBhZGRlZCB0byBidWxrIGluc2VydCBhZnRlciBleGVjdXRpb24gaGFzIHN0YXJ0ZWQuJyk7XG4gICAgfVxuXG4gICAgY29uc3QgY29sdW1uOiBDb2x1bW4gPSB7XG4gICAgICB0eXBlOiB0eXBlLFxuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgb3V0cHV0OiBvdXRwdXQsXG4gICAgICBsZW5ndGg6IGxlbmd0aCxcbiAgICAgIHByZWNpc2lvbjogcHJlY2lzaW9uLFxuICAgICAgc2NhbGU6IHNjYWxlLFxuICAgICAgb2JqTmFtZTogb2JqTmFtZSxcbiAgICAgIG51bGxhYmxlOiBudWxsYWJsZSxcbiAgICAgIGNvbGxhdGlvbjogdGhpcy5jb2xsYXRpb25cbiAgICB9O1xuXG4gICAgaWYgKCh0eXBlLmlkICYgMHgzMCkgPT09IDB4MjApIHtcbiAgICAgIGlmIChjb2x1bW4ubGVuZ3RoID09IG51bGwgJiYgdHlwZS5yZXNvbHZlTGVuZ3RoKSB7XG4gICAgICAgIGNvbHVtbi5sZW5ndGggPSB0eXBlLnJlc29sdmVMZW5ndGgoY29sdW1uKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZS5yZXNvbHZlUHJlY2lzaW9uICYmIGNvbHVtbi5wcmVjaXNpb24gPT0gbnVsbCkge1xuICAgICAgY29sdW1uLnByZWNpc2lvbiA9IHR5cGUucmVzb2x2ZVByZWNpc2lvbihjb2x1bW4pO1xuICAgIH1cblxuICAgIGlmICh0eXBlLnJlc29sdmVTY2FsZSAmJiBjb2x1bW4uc2NhbGUgPT0gbnVsbCkge1xuICAgICAgY29sdW1uLnNjYWxlID0gdHlwZS5yZXNvbHZlU2NhbGUoY29sdW1uKTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbHVtbnMucHVzaChjb2x1bW4pO1xuXG4gICAgdGhpcy5jb2x1bW5zQnlOYW1lW25hbWVdID0gY29sdW1uO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSByb3cgdG8gdGhlIGJ1bGsgaW5zZXJ0LlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBidWxrTG9hZC5hZGRSb3coeyBmaXJzdF9uYW1lOiAnQmlsbCcsIGxhc3RfbmFtZTogJ0dhdGVzJyB9KTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSByb3cgQW4gb2JqZWN0IG9mIGtleS92YWx1ZSBwYWlycyByZXByZXNlbnRpbmcgY29sdW1uIG5hbWUgKG9yIG9iak5hbWUpIGFuZCB2YWx1ZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVGhpcyBtZXRob2QgaXMgZGVwcmVjYXRlZC4gSW5zdGVhZCBvZiBhZGRpbmcgcm93cyBpbmRpdmlkdWFsbHksIHlvdSBzaG91bGQgcGFzc1xuICAgKiAgIGFsbCByb3cgb2JqZWN0cyB3aGVuIGNhbGxpbmcgW1tDb25uZWN0aW9uLmV4ZWNCdWxrTG9hZF1dLiBUaGlzIG1ldGhvZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIGZ1dHVyZS5cbiAgICovXG4gIGFkZFJvdyhyb3c6IHsgW2NvbHVtbk5hbWU6IHN0cmluZ106IHVua25vd24gfSk6IHZvaWRcblxuICAvKipcbiAgICogQWRkcyBhIHJvdyB0byB0aGUgYnVsayBpbnNlcnQuXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIGJ1bGtMb2FkLmFkZFJvdygnQmlsbCcsICdHYXRlcycpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHJvdyBJZiB0aGVyZSBhcmUgYXQgbGVhc3QgdHdvIGNvbHVtbnMsIHZhbHVlcyBjYW4gYmUgcGFzc2VkIGFzIG11bHRpcGxlIGFyZ3VtZW50cyBpbnN0ZWFkIG9mIGFuIGFycmF5LiBUaGV5XG4gICAqICAgbXVzdCBiZSBpbiB0aGUgc2FtZSBvcmRlciB0aGUgY29sdW1ucyB3ZXJlIGFkZGVkIGluLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBUaGlzIG1ldGhvZCBpcyBkZXByZWNhdGVkLiBJbnN0ZWFkIG9mIGFkZGluZyByb3dzIGluZGl2aWR1YWxseSwgeW91IHNob3VsZCBwYXNzXG4gICAqICAgYWxsIHJvdyBvYmplY3RzIHdoZW4gY2FsbGluZyBbW0Nvbm5lY3Rpb24uZXhlY0J1bGtMb2FkXV0uIFRoaXMgbWV0aG9kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgZnV0dXJlLlxuICAgKi9cbiAgYWRkUm93KC4uLnJvdzogdW5rbm93bltdKTogdm9pZFxuXG4gIC8qKlxuICAgKiBBZGRzIGEgcm93IHRvIHRoZSBidWxrIGluc2VydC5cbiAgICpcbiAgICogYGBganNcbiAgICogYnVsa0xvYWQuYWRkUm93KFsnQmlsbCcsICdHYXRlcyddKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSByb3cgQW4gYXJyYXkgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZXMgb2YgZWFjaCBjb2x1bW4gaW4gdGhlIHNhbWUgb3JkZXIgd2hpY2ggdGhleSB3ZXJlIGFkZGVkIHRvIHRoZSBidWxrTG9hZCBvYmplY3QuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFRoaXMgbWV0aG9kIGlzIGRlcHJlY2F0ZWQuIEluc3RlYWQgb2YgYWRkaW5nIHJvd3MgaW5kaXZpZHVhbGx5LCB5b3Ugc2hvdWxkIHBhc3NcbiAgICogICBhbGwgcm93IG9iamVjdHMgd2hlbiBjYWxsaW5nIFtbQ29ubmVjdGlvbi5leGVjQnVsa0xvYWRdXS4gVGhpcyBtZXRob2Qgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBmdXR1cmUuXG4gICAqL1xuICBhZGRSb3cocm93OiB1bmtub3duW10pOiB2b2lkXG5cbiAgYWRkUm93KC4uLmlucHV0OiBbIHsgW2tleTogc3RyaW5nXTogdW5rbm93biB9IF0gfCB1bmtub3duW10pIHtcbiAgICB0aGlzLmZpcnN0Um93V3JpdHRlbiA9IHRydWU7XG5cbiAgICBsZXQgcm93OiBhbnk7XG4gICAgaWYgKGlucHV0Lmxlbmd0aCA+IDEgfHwgIWlucHV0WzBdIHx8IHR5cGVvZiBpbnB1dFswXSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJvdyA9IGlucHV0O1xuICAgIH0gZWxzZSB7XG4gICAgICByb3cgPSBpbnB1dFswXTtcbiAgICB9XG5cbiAgICAvLyB3cml0ZSBlYWNoIGNvbHVtblxuICAgIGlmIChBcnJheS5pc0FycmF5KHJvdykpIHtcbiAgICAgIHRoaXMucm93VG9QYWNrZXRUcmFuc2Zvcm0ud3JpdGUodGhpcy5jb2x1bW5zLm1hcCgoY29sdW1uLCBpKSA9PiB7XG4gICAgICAgIHJldHVybiBjb2x1bW4udHlwZS52YWxpZGF0ZShyb3dbaV0sIGNvbHVtbi5jb2xsYXRpb24pO1xuICAgICAgfSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJvd1RvUGFja2V0VHJhbnNmb3JtLndyaXRlKHRoaXMuY29sdW1ucy5tYXAoKGNvbHVtbikgPT4ge1xuICAgICAgICByZXR1cm4gY29sdW1uLnR5cGUudmFsaWRhdGUocm93W2NvbHVtbi5vYmpOYW1lXSwgY29sdW1uLmNvbGxhdGlvbik7XG4gICAgICB9KSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRPcHRpb25zU3FsKCkge1xuICAgIGNvbnN0IGFkZE9wdGlvbnMgPSBbXTtcblxuICAgIGlmICh0aGlzLmJ1bGtPcHRpb25zLmNoZWNrQ29uc3RyYWludHMpIHtcbiAgICAgIGFkZE9wdGlvbnMucHVzaCgnQ0hFQ0tfQ09OU1RSQUlOVFMnKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5idWxrT3B0aW9ucy5maXJlVHJpZ2dlcnMpIHtcbiAgICAgIGFkZE9wdGlvbnMucHVzaCgnRklSRV9UUklHR0VSUycpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmJ1bGtPcHRpb25zLmtlZXBOdWxscykge1xuICAgICAgYWRkT3B0aW9ucy5wdXNoKCdLRUVQX05VTExTJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYnVsa09wdGlvbnMubG9ja1RhYmxlKSB7XG4gICAgICBhZGRPcHRpb25zLnB1c2goJ1RBQkxPQ0snKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5idWxrT3B0aW9ucy5vcmRlcikge1xuICAgICAgY29uc3Qgb3JkZXJDb2x1bW5zID0gW107XG5cbiAgICAgIGZvciAoY29uc3QgW2NvbHVtbiwgZGlyZWN0aW9uXSBvZiBPYmplY3QuZW50cmllcyh0aGlzLmJ1bGtPcHRpb25zLm9yZGVyKSkge1xuICAgICAgICBvcmRlckNvbHVtbnMucHVzaChgJHtjb2x1bW59ICR7ZGlyZWN0aW9ufWApO1xuICAgICAgfVxuXG4gICAgICBpZiAob3JkZXJDb2x1bW5zLmxlbmd0aCkge1xuICAgICAgICBhZGRPcHRpb25zLnB1c2goYE9SREVSICgke29yZGVyQ29sdW1ucy5qb2luKCcsICcpfSlgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYWRkT3B0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gYCBXSVRIICgke2FkZE9wdGlvbnMuam9pbignLCcpfSlgO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRCdWxrSW5zZXJ0U3FsKCkge1xuICAgIGxldCBzcWwgPSAnaW5zZXJ0IGJ1bGsgJyArIHRoaXMudGFibGUgKyAnKCc7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRoaXMuY29sdW1ucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgY29uc3QgYyA9IHRoaXMuY29sdW1uc1tpXTtcbiAgICAgIGlmIChpICE9PSAwKSB7XG4gICAgICAgIHNxbCArPSAnLCAnO1xuICAgICAgfVxuICAgICAgc3FsICs9ICdbJyArIGMubmFtZSArICddICcgKyAoYy50eXBlLmRlY2xhcmF0aW9uKGMpKTtcbiAgICB9XG4gICAgc3FsICs9ICcpJztcblxuICAgIHNxbCArPSB0aGlzLmdldE9wdGlvbnNTcWwoKTtcbiAgICByZXR1cm4gc3FsO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgc2ltcGx5IGEgaGVscGVyIHV0aWxpdHkgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhIGBDUkVBVEUgVEFCTEUgU1FMYCBzdGF0ZW1lbnQgYmFzZWQgb24gdGhlIGNvbHVtbnMgYWRkZWQgdG8gdGhlIGJ1bGtMb2FkIG9iamVjdC5cbiAgICogVGhpcyBtYXkgYmUgcGFydGljdWxhcmx5IGhhbmR5IHdoZW4geW91IHdhbnQgdG8gaW5zZXJ0IGludG8gYSB0ZW1wb3JhcnkgdGFibGUgKGEgdGFibGUgd2hpY2ggc3RhcnRzIHdpdGggYCNgKS5cbiAgICpcbiAgICogYGBganNcbiAgICogdmFyIHNxbCA9IGJ1bGtMb2FkLmdldFRhYmxlQ3JlYXRpb25TcWwoKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEEgc2lkZSBub3RlIG9uIGJ1bGsgaW5zZXJ0aW5nIGludG8gdGVtcG9yYXJ5IHRhYmxlczogaWYgeW91IHdhbnQgdG8gYWNjZXNzIGEgbG9jYWwgdGVtcG9yYXJ5IHRhYmxlIGFmdGVyIGV4ZWN1dGluZyB0aGUgYnVsayBsb2FkLFxuICAgKiB5b3UnbGwgbmVlZCB0byB1c2UgdGhlIHNhbWUgY29ubmVjdGlvbiBhbmQgZXhlY3V0ZSB5b3VyIHJlcXVlc3RzIHVzaW5nIFtbQ29ubmVjdGlvbi5leGVjU3FsQmF0Y2hdXSBpbnN0ZWFkIG9mIFtbQ29ubmVjdGlvbi5leGVjU3FsXV1cbiAgICovXG4gIGdldFRhYmxlQ3JlYXRpb25TcWwoKSB7XG4gICAgbGV0IHNxbCA9ICdDUkVBVEUgVEFCTEUgJyArIHRoaXMudGFibGUgKyAnKFxcbic7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRoaXMuY29sdW1ucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgY29uc3QgYyA9IHRoaXMuY29sdW1uc1tpXTtcbiAgICAgIGlmIChpICE9PSAwKSB7XG4gICAgICAgIHNxbCArPSAnLFxcbic7XG4gICAgICB9XG4gICAgICBzcWwgKz0gJ1snICsgYy5uYW1lICsgJ10gJyArIChjLnR5cGUuZGVjbGFyYXRpb24oYykpO1xuICAgICAgaWYgKGMubnVsbGFibGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzcWwgKz0gJyAnICsgKGMubnVsbGFibGUgPyAnTlVMTCcgOiAnTk9UIE5VTEwnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3FsICs9ICdcXG4pJztcbiAgICByZXR1cm4gc3FsO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRDb2xNZXRhRGF0YSgpIHtcbiAgICBjb25zdCB0QnVmID0gbmV3IFdyaXRhYmxlVHJhY2tpbmdCdWZmZXIoMTAwLCBudWxsLCB0cnVlKTtcbiAgICAvLyBUb2tlblR5cGVcbiAgICB0QnVmLndyaXRlVUludDgoVE9LRU5fVFlQRS5DT0xNRVRBREFUQSk7XG4gICAgLy8gQ291bnRcbiAgICB0QnVmLndyaXRlVUludDE2TEUodGhpcy5jb2x1bW5zLmxlbmd0aCk7XG5cbiAgICBmb3IgKGxldCBqID0gMCwgbGVuID0gdGhpcy5jb2x1bW5zLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICBjb25zdCBjID0gdGhpcy5jb2x1bW5zW2pdO1xuICAgICAgLy8gVXNlclR5cGVcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudGRzVmVyc2lvbiA8ICc3XzInKSB7XG4gICAgICAgIHRCdWYud3JpdGVVSW50MTZMRSgwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRCdWYud3JpdGVVSW50MzJMRSgwKTtcbiAgICAgIH1cblxuICAgICAgLy8gRmxhZ3NcbiAgICAgIGxldCBmbGFncyA9IEZMQUdTLnVwZGF0ZWFibGVSZWFkV3JpdGU7XG4gICAgICBpZiAoYy5udWxsYWJsZSkge1xuICAgICAgICBmbGFncyB8PSBGTEFHUy5udWxsYWJsZTtcbiAgICAgIH0gZWxzZSBpZiAoYy5udWxsYWJsZSA9PT0gdW5kZWZpbmVkICYmIHRoaXMub3B0aW9ucy50ZHNWZXJzaW9uID49ICc3XzInKSB7XG4gICAgICAgIGZsYWdzIHw9IEZMQUdTLm51bGxhYmxlVW5rbm93bjtcbiAgICAgIH1cbiAgICAgIHRCdWYud3JpdGVVSW50MTZMRShmbGFncyk7XG5cbiAgICAgIC8vIFRZUEVfSU5GT1xuICAgICAgdEJ1Zi53cml0ZUJ1ZmZlcihjLnR5cGUuZ2VuZXJhdGVUeXBlSW5mbyhjLCB0aGlzLm9wdGlvbnMpKTtcblxuICAgICAgLy8gVGFibGVOYW1lXG4gICAgICBpZiAoYy50eXBlLmhhc1RhYmxlTmFtZSkge1xuICAgICAgICB0QnVmLndyaXRlVXNWYXJjaGFyKHRoaXMudGFibGUsICd1Y3MyJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIENvbE5hbWVcbiAgICAgIHRCdWYud3JpdGVCVmFyY2hhcihjLm5hbWUsICd1Y3MyJyk7XG4gICAgfVxuICAgIHJldHVybiB0QnVmLmRhdGE7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBhIHRpbWVvdXQgZm9yIHRoaXMgYnVsayBsb2FkLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBidWxrTG9hZC5zZXRUaW1lb3V0KHRpbWVvdXQpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHRpbWVvdXQgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgYmVmb3JlIHRoZSBidWxrIGxvYWQgaXMgY29uc2lkZXJlZCBmYWlsZWQsIG9yIDAgZm9yIG5vIHRpbWVvdXQuXG4gICAqICAgV2hlbiBubyB0aW1lb3V0IGlzIHNldCBmb3IgdGhlIGJ1bGsgbG9hZCwgdGhlIFtbQ29ubmVjdGlvbk9wdGlvbnMucmVxdWVzdFRpbWVvdXRdXSBvZiB0aGUgQ29ubmVjdGlvbiBpcyB1c2VkLlxuICAgKi9cbiAgc2V0VGltZW91dCh0aW1lb3V0PzogbnVtYmVyKSB7XG4gICAgdGhpcy50aW1lb3V0ID0gdGltZW91dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY3JlYXRlRG9uZVRva2VuKCkge1xuICAgIC8vIEl0IG1pZ2h0IGJlIG5pY2UgdG8gbWFrZSBEb25lVG9rZW4gYSBjbGFzcyBpZiBhbnl0aGluZyBuZWVkcyB0byBjcmVhdGUgdGhlbSwgYnV0IGZvciBub3csIGp1c3QgZG8gaXQgaGVyZVxuICAgIGNvbnN0IHRCdWYgPSBuZXcgV3JpdGFibGVUcmFja2luZ0J1ZmZlcih0aGlzLm9wdGlvbnMudGRzVmVyc2lvbiA8ICc3XzInID8gOSA6IDEzKTtcbiAgICB0QnVmLndyaXRlVUludDgoVE9LRU5fVFlQRS5ET05FKTtcbiAgICBjb25zdCBzdGF0dXMgPSBET05FX1NUQVRVUy5GSU5BTDtcbiAgICB0QnVmLndyaXRlVUludDE2TEUoc3RhdHVzKTtcbiAgICB0QnVmLndyaXRlVUludDE2TEUoMCk7IC8vIEN1ckNtZCAoVERTIGlnbm9yZXMgdGhpcylcbiAgICB0QnVmLndyaXRlVUludDMyTEUoMCk7IC8vIHJvdyBjb3VudCAtIGRvZXNuJ3QgcmVhbGx5IG1hdHRlclxuICAgIGlmICh0aGlzLm9wdGlvbnMudGRzVmVyc2lvbiA+PSAnN18yJykge1xuICAgICAgdEJ1Zi53cml0ZVVJbnQzMkxFKDApOyAvLyByb3cgY291bnQgaXMgNjQgYml0cyBpbiA+PSBURFMgNy4yXG4gICAgfVxuICAgIHJldHVybiB0QnVmLmRhdGE7XG4gIH1cblxuICAvKipcbiAgICogU3dpdGNoZXMgdGhlIGBCdWxrTG9hZGAgb2JqZWN0IGludG8gc3RyZWFtaW5nIG1vZGUgYW5kIHJldHVybnMgYVxuICAgKiBbd3JpdGFibGUgc3RyZWFtXShodHRwczovL25vZGVqcy5vcmcvZGlzdC9sYXRlc3QtdjEwLngvZG9jcy9hcGkvc3RyZWFtLmh0bWwjc3RyZWFtX3dyaXRhYmxlX3N0cmVhbXMpXG4gICAqIHRoYXQgY2FuIGJlIHVzZWQgdG8gc2VuZCBhIGxhcmdlIGFtb3VudCBvZiByb3dzIHRvIHRoZSBzZXJ2ZXIuXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IGJ1bGtMb2FkID0gY29ubmVjdGlvbi5uZXdCdWxrTG9hZCguLi4pO1xuICAgKiBidWxrTG9hZC5hZGRDb2x1bW4oLi4uKTtcbiAgICpcbiAgICogY29uc3Qgcm93U3RyZWFtID0gYnVsa0xvYWQuZ2V0Um93U3RyZWFtKCk7XG4gICAqXG4gICAqIGNvbm5lY3Rpb24uZXhlY0J1bGtMb2FkKGJ1bGtMb2FkKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEluIHN0cmVhbWluZyBtb2RlLCBbW2FkZFJvd11dIGNhbm5vdCBiZSB1c2VkLiBJbnN0ZWFkIGFsbCBkYXRhIHJvd3MgbXVzdCBiZSB3cml0dGVuIHRvIHRoZSByZXR1cm5lZCBzdHJlYW0gb2JqZWN0LlxuICAgKiBUaGUgc3RyZWFtIGltcGxlbWVudGF0aW9uIHVzZXMgZGF0YSBmbG93IGNvbnRyb2wgdG8gcHJldmVudCBtZW1vcnkgb3ZlcmxvYWQuIFtgc3RyZWFtLndyaXRlKClgXShodHRwczovL25vZGVqcy5vcmcvZGlzdC9sYXRlc3QtdjEwLngvZG9jcy9hcGkvc3RyZWFtLmh0bWwjc3RyZWFtX3dyaXRhYmxlX3dyaXRlX2NodW5rX2VuY29kaW5nX2NhbGxiYWNrKVxuICAgKiByZXR1cm5zIGBmYWxzZWAgdG8gaW5kaWNhdGUgdGhhdCBkYXRhIHRyYW5zZmVyIHNob3VsZCBiZSBwYXVzZWQuXG4gICAqXG4gICAqIEFmdGVyIHRoYXQsIHRoZSBzdHJlYW0gZW1pdHMgYSBbJ2RyYWluJyBldmVudF0oaHR0cHM6Ly9ub2RlanMub3JnL2Rpc3QvbGF0ZXN0LXYxMC54L2RvY3MvYXBpL3N0cmVhbS5odG1sI3N0cmVhbV9ldmVudF9kcmFpbilcbiAgICogd2hlbiBpdCBpcyByZWFkeSB0byByZXN1bWUgZGF0YSB0cmFuc2Zlci5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogICBUaGlzIG1ldGhvZCBpcyBkZXByZWNhdGVkLiBJbnN0ZWFkIG9mIHdyaXRpbmcgcm93cyB0byB0aGUgc3RyZWFtIHJldHVybmVkIGJ5IHRoaXMgbWV0aG9kLFxuICAgKiAgIHlvdSBjYW4gcGFzcyBhbnkgb2JqZWN0IHRoYXQgaW1wbGVtZW50cyB0aGUgYEl0ZXJhYmxlYCBvciBgQXN5bmNJdGVyYWJsZWAgaW50ZXJmYWNlIChlLmcuIGEgYFJlYWRhYmxlYFxuICAgKiAgIHN0cmVhbSBvciBhbiBgQXN5bmNHZW5lcmF0b3JgKSB3aGVuIGNhbGxpbmcgW1tDb25uZWN0aW9uLmV4ZWNCdWxrTG9hZF1dLiBUaGlzIG1ldGhvZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIGZ1dHVyZS5cbiAgICovXG4gIGdldFJvd1N0cmVhbSgpIHtcbiAgICBpZiAodGhpcy5maXJzdFJvd1dyaXR0ZW4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQnVsa0xvYWQgY2Fubm90IGJlIHN3aXRjaGVkIHRvIHN0cmVhbWluZyBtb2RlIGFmdGVyIGZpcnN0IHJvdyBoYXMgYmVlbiB3cml0dGVuIHVzaW5nIGFkZFJvdygpLicpO1xuICAgIH1cbiAgICBpZiAodGhpcy5leGVjdXRpb25TdGFydGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0J1bGtMb2FkIGNhbm5vdCBiZSBzd2l0Y2hlZCB0byBzdHJlYW1pbmcgbW9kZSBhZnRlciBleGVjdXRpb24gaGFzIHN0YXJ0ZWQuJyk7XG4gICAgfVxuICAgIHRoaXMuc3RyZWFtaW5nTW9kZSA9IHRydWU7XG5cbiAgICByZXR1cm4gdGhpcy5yb3dUb1BhY2tldFRyYW5zZm9ybTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY2FuY2VsKCkge1xuICAgIGlmICh0aGlzLmNhbmNlbGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5jYW5jZWxlZCA9IHRydWU7XG4gICAgdGhpcy5lbWl0KCdjYW5jZWwnKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBCdWxrTG9hZDtcbm1vZHVsZS5leHBvcnRzID0gQnVsa0xvYWQ7XG4iXX0=